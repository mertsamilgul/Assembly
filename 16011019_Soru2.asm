MYSS	SEGMENT PARA STACK
        DW 100 DUP (?)
MYSS	ENDS
MYDS	SEGMENT PARA 
CR		EQU 13
LF		EQU 10
N 		DW ?
ARR		DB 100 DUP(?)
MSG1	DB 'DIZININ ELEMAN SAYISINI GIRINIZ: ',0
MSG2	DB 'DIZININ ',0
MSG3	DB '. ELEMANINI GIRINIZ: ',0
HATA	DB CR,LF,'LUTFEN TAMSAYI GIRINIZ: ',0
BHATA	DB 'YAZDIGINIZ SAYI BYTE DEGIL! ',CR,LF,0
SONUC	DB CR,LF, 'SIRALANMIS DIZI: ',0
MYDS    ENDS
MYCS	SEGMENT PARA 
		ASSUME SS:MYSS, DS:MYDS, CS :MYCS
ANA		PROC FAR
		PUSH DS
		XOR AX,AX
		PUSH AX
		MOV AX,MYDS
		MOV DS,AX
		; BX - LOW
		; CX - HIGH
		; AX - PIVOT
		; DX - PI
		; SI - I
		; DI - J
		MOV AX,OFFSET MSG1  ; 'DIZININ ELEMAN SAYISINI GIRINIZ: ' OFFSETI AX E ATILIR
		CALL PUT_STR		; 'DIZININ ELEMAN SAYISINI GIRINIZ: ' YAZDIRILIR
		CALL GETN 			; N ALINIR.
		MOV N,AX			;
		MOV CX,N			; N DEGERI DONGU ICIN CX E ATILIR.
		LEA DI,ARR			; DIZININ BASLANGIC ADRESI DI YA ATILIR.
		
L1:		MOV AX,OFFSET MSG2 	; 'DIZININ ' OFFSETI AX E ATILIR.
		CALL PUT_STR		; 'DIZININ ' YAZDIRILIR.
		MOV AX,N			; AX E N ATILIR.
		SUB AX,CX			; AX'TEN CX CIKARTILIR AX->i OLUR.
		CALL PUTN			; AX(ELEMANIN INDEXI) YAZDIRILIR.
		MOV AX,OFFSET MSG3	; '. ELEMANINI GIRINIZ: ' OFFSETI AX E ATILIR.
		CALL PUT_STR		; '. ELEMANINI GIRINIZ: ' YAZDIRILIR.
		CALL GETN			; GIRILEN ELEMAN AX E ALINIR.
		CMP AX,-128			; 
		JGE KONT2			; GIRILEN ELEMAN -128 DEN BUYUKSE 2. KONTROL YAPILIR.
BHA:	MOV AX,OFFSET BHATA	; 
		CALL PUT_STR		; -128 DEN KUCUK OLDUGU ICIN HATA VERIR,
		JMP L1				; VE SAYI TEKRAR ISTENIR.
KONT2:	CMP AX,127			; 2. KONTROL YAPILIR,
		JG BHA				; 127DEN BUYUKSE HATA VERIR.
		MOV BYTE PTR[DI],AL	; ELEMAN BYTE OLDUGU ICIN DIZIYE ALINIR.
		INC DI				; 
		LOOP L1				; ISLEM TEKRAR EDER.
		
		XOR AX,AX			;
		MOV BX,0			; BX YANI LOW -> 0 A ESITLENIR.
		MOV CX,N			; CX YANI HIGH,
		DEC CX				; N-1 E ESITLENIR.
		CALL QUICK			; RECURSIVE FONK CAGIRILIR
		
		MOV AX,OFFSET SONUC	; 
		CALL PUT_STR        ; 'SIRALANMIS DIZI: ' YAZDIRILIR
		
		MOV CX,N			; CX E N ATILIR.
		LEA DI,ARR			; DIZININ BASLANGICI DI YA ATILIR.		
L3:		MOV AL,BYTE PTR[DI]	; DIZI ELEMANI AL YE ALINIR.
		CMP AL,0			; 0 DAN KUCUK MU DIYE BAKILIR,
		JL EKSI				; KUCUKSE EKSI LABELINA GIDER.
		XOR AH,AH			; 0 DAN BUYUK OLDUGUNDAN AH 0 LANIR,
		JMP ARTI			; ARTI LABELINA GIDER.
EKSI:	MOV AH,0FFH			; EKSI OLDUGUNDAN AH FF YAPILIR.
ARTI:	CALL PUTN			; ELEMAN YAZDIRILIR.
		MOV AL,32			; BOSLUK KARAKTERI AL YE ATILIR.
		CALL PUTC			; DEGERLER ARASI BOSLUK KOYULUR.
		INC DI				; DI ARTTIRILIR.
		LOOP L3				; ISLEM TEKRAR EDER.
		
		RETF
ANA 	ENDP

PART	PROC NEAR			; PARTITION FONSKIYONU.
		XOR AX,AX			; AX=PIVOT 0 LANIR.
		PUSH DI				; CX REGISTERI DIZI INDEXI 
		MOV DI,CX			; OLARAK KULLANILAMADIGINDAN,
		MOV AL,ARR[DI]		; ISLEM DI UZERINDEN GERCEKLESTIRILIR.
		POP DI				; DI ESKI DEGERINI ALIR.
		PUSH BX				; BX=LOW DEGERI SAKLANIR
		DEC BX				; 1 AZALTILIP,
		MOV SI,BX			; SI=i YE ATILIR,
		POP BX				; BX ESKI DEGERINI ALIR.
		PUSH CX				; CX=HIGH DEGERI LOOPTA KULLANILDIGI ICIN SAKLANIR.
		SUB CX,BX			; LOOP DONME SAYISI CX-BX(HIGH-LOW) YAPILIR.
		MOV DI,BX			; BX(j) LOW DAN BASLAYACAGI ICIN ESITLENIR.
		
L2:		CMP ARR[DI],AL		; DIZI[j] <= PIVOT KONTROLU YAPILIR.
		JG DEVAM			; BUYUKSE IF E GIRMEZ FOR UN SONUNA GIDER.
		INC SI				; DEGILSE IF IN ICINE GIRER i ARTTIRILIR
		PUSH AX				; 
		PUSH BX				;
		MOV AL,ARR[SI]		;
		MOV BL,ARR[DI]		;
		MOV ARR[SI],BL		;
		MOV ARR[DI],AL		;
		POP BX				;
		POP AX				;
DEVAM:	INC DI				;
		LOOP L2				;
	
		POP CX				;
		PUSH AX				;
		MOV AL,ARR[SI+1]	;
		PUSH DI				;
		MOV DI,CX			;
		PUSH BX				;
		MOV BL,ARR[DI]		;
		MOV ARR[SI+1],BL	;
		MOV ARR[DI],AL		;
		POP BX				;
		POP DI				;
		POP AX				;
		
		PUSH SI				;
		INC SI				;
		MOV DX,SI			;
		POP SI				;
		RET	
PART	ENDP

QUICK	PROC NEAR			; QUICKSORT FONKSIYONU
		CMP BX,CX			;
		JGE CIK				;
		CALL PART			;
		PUSH CX				;
		MOV CX,DX			;
		DEC CX				;
		CALL QUICK			;
		POP CX				;
		PUSH BX				;
		MOV BX,DX			;
		INC BX				;
		CALL QUICK			;
		POP BX				;
CIK:	RET		
QUICK	ENDP

GETC	PROC NEAR
		MOV AH,1H
		INT 21H
		RET
GETC	ENDP
PUTC	PROC NEAR
		PUSH AX
		PUSH DX
		MOV DL,AL
		MOV AH,2
		INT 21H
		POP DX
		POP AX
		RET
PUTC 	ENDP
GETN	PROC NEAR
		PUSH BX
		PUSH CX
		PUSH DX
GETN_START:
		MOV DX,1
		XOR BX,BX
		XOR CX,CX
NEW:
		CALL GETC
		CMP AL,CR
		JE FIN_READ
		CMP AL,'-'
		JNE CTRL_NUM
NEGATIVE:
		MOV DX, -1
		JMP NEW
CTRL_NUM:
		CMP AL,'0'
		JB ERROR
		CMP AL,'9'
		JA ERROR
		SUB AL,'0'
		MOV BL,AL
		MOV AX,10
		PUSH DX
		MUL CX
		POP DX
		MOV CX,AX
		ADD CX,BX
		JMP NEW
ERROR:	
		MOV AX, OFFSET HATA
		CALL PUT_STR
		JMP GETN_START
FIN_READ: 
		MOV AX,CX
		CMP DX,1
		JE FIN_GETN
		NEG AX
FIN_GETN:
		POP DX
		POP CX
		POP DX
		RET
GETN	ENDP
PUTN	PROC NEAR
		PUSH CX
		PUSH DX
		XOR DX,DX
		PUSH DX
		MOV CX,10
		CMP AX,0
		JGE CALC_DIGITS
		NEG AX
		PUSH AX
		MOV AL,'-'
		CALL PUTC
		POP AX
CALC_DIGITS:
		DIV CX
		ADD DX,'0'
		PUSH DX
		XOR DX,DX
		CMP AX,0
		JNE CALC_DIGITS
DISP_LOOP:
		POP AX
		CMP AX,0
		JE END_DISP_LOOP
		CALL PUTC
		JMP DISP_LOOP
END_DISP_LOOP:
		POP DX
		POP CX
		RET
PUTN 	ENDP
PUT_STR	PROC NEAR
		PUSH BX
		MOV BX,AX
		MOV AL,BYTE PTR[BX]
PUT_LOOP:
		CMP AL,0
		JE PUT_FIN
		CALL PUTC
		INC BX
		MOV AL,BYTE PTR[BX]
		JMP PUT_LOOP
PUT_FIN:
		POP BX
		RET
PUT_STR ENDP
	
mycs	ENDS
		END ANA